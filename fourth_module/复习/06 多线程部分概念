进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程才是cpu上的执行单位。

多线程（即多个控制线程）的概念是，在一个进程中存在多个线程，多个线程共享该进程的地址空间

进程和线程最大的区别在于:
    同一个进程内的多个线程共享该进程内的地址资源
    创建线程的开销要远小于创建进程的开销


多线程与多进程的区别
1.开启线程的开销比开启进程的开销要小。
2.线程的PID与开启线程的进程的PID相同，就不需要重新去申请内存地址空间。进程在开启子进程就需要去申请，因此，速度慢。
3.进程之间的数据是相互隔离的。同一进程内开启的多个线程是共享该进程地址空间的


Thread实例对象的方法
  # isAlive(): 返回线程是否活动的。
  # getName(): 返回线程名。
  # setName(): 设置线程名。

threading模块提供的一些方法：
  # threading.currentThread(): 返回当前的线程变量。
  # threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
  # threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。


守护进程或者线程在线程或者进程里面的判断：
    无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁
    需要强调的是：运行完毕并非终止运行

        1、对主进程来说，运行完毕指的是主进程代码运行完毕
        2、对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕


        详细解释：
            1、主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，
            2、主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。



1、对计算来说，cpu越多越好，但是对于I/O来说，再多的cpu也没用
2、当然对运行一个程序来说，随着cpu的增多执行效率肯定会有所提高（不管提高幅度多大，总会有所提高），这是因为一个程序基本上不会是纯计算或者纯I/O，所以我们只能相对的去看一个程序到底是计算密集型还是I/O密集型，从而进一步分析python的多线程到底有无用武之地



很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，
其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、
减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。





