CPU 主要用于计算

多道技术：
    1.产生背景：针对单核，实现并发（并不是真正意义上的并行）
    ps：
        现在的主机一般是多核，那么每个核都会利用多道技术
        有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个
        cpu中的任意一个，具体由操作系统调度算法决定。

    2.空间上的复用：如内存中同时有多道程序
    3.时间上的复用：复用一个cpu的时间片
        强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样才能保证下次切换回来时，能基于上次切走的位置继续运行

并发与并行
    一 并发：是伪并行，即看起来是同时运行。单个cpu+多道技术就可以实现并发，（并行也属于并发）
    二 并行：同时运行，只有具备多个cpu才能实现并行

同步与异步
    同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不会返回。按照这个定义，其实绝大多数函数都是同步调用。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。
        举例：
        #1. multiprocessing.Pool下的apply #发起同步调用后，就在原地等着任务结束，根本不考虑任务是在计算还是在io阻塞，总之就是一股脑地等任务结束
        #2. concurrent.futures.ProcessPoolExecutor().submit(func,).result()
        #3. concurrent.futures.ThreadPoolExecutor().submit(func,).result()


    异步：异步的概念和同步相对。当一个异步功能调用发出后，调用者不能立刻得到结果。当该异步功能完成后，通过状态、通知或回调来通知调用者。如果异步功能用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为异步功能几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。
    举例：
        1. multiprocessing.Pool().apply_async() #发起异步调用后，并不会等待任务结束才返回，相反，会立即获取一个临时结果（并不是最终的结果，可能是封装好的一个对象）。
        2. concurrent.futures.ProcessPoolExecutor(3).submit(func,)
        3. concurrent.futures.ThreadPoolExecutor(3).submit(func,)func

在UNIX创建的子进程，会拷贝父进程的初始状态。

Process类介绍
Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）
参数介绍：
    group参数未使用，值始终为None
    target表示调用对象，即子进程要执行的任务
    args表示调用对象的位置参数元组，args=(1,2,'egon',)
    kwargs表示调用对象的字典,kwargs={'name':'egon','age':18}
    name为子进程的名称
方法介绍：
    p = Process(target=func,kwargs ={})
    p.start() ：启动进程，并调用该子进程中的p.run()
    p.terminate():强制终止进程p，不会进行任何操作，如果p 创建了 子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p 还保存了一个锁那么也将不会释放，进而导致死锁。
    p.join() :主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间。

属性介绍：
    p.daemon: 默认值为False，如果设为True，代表p 为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须p.start()之前设置
    p.name: 进程的名称。
    p.pid : 进程的pid

在主进程运行过程中如果想并发的执行其他任务，可以开启子进程，此时主进程的任务与子进程的任务分为两种情况：
情况一：在主进程的任务与子进程的任务彼此独立的情况下，主进程的任务先执行完毕后，主进程还需要等待子进程执行完毕，然后统一回收资源。
情况二：如果主进程的任务在执行到某一阶段时，需要等待子进程执行完毕后才能继续执行，就需要有一种机制能够让主进程检测子进程是否运行完毕，在子进程执行完毕后才继续执行，否则在原地阻塞，这就可以用到 join方法。


队列才是进程间通信的最佳选择



生产者消费者：
    生产者指的是生产数据的任务，消费者指的是处理数据的任务

什么是生产者和消费者模式
    生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。
    这个阻塞队列就是用来给生产者和消费者解耦的

生产者消费则模型总结：
1、程序中有两类角色。
    1.负责生产数据（生产者）
    2.负责处理数据（消费者）

2、引入生产者消费则模型为了解决的问题是
    1.平衡生产者与消费则之间的速度差
    2.程序解开耦合

3、如何实现生产者消费则模型
    生产者<--->队列<--->消费者









